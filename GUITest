import tkinter
import pygeoip
from tabview import TabView
from tkinter import messagebox


class FindLocation(object):
    def __init__(self):
        self.gi = pygeoip.GeoIP("./GeoLiteCity.dat")
        # 创建主窗口,用于容纳其它组件
        self.root = tkinter.Tk()
        # 给主窗口设置标题内容
        self.root.title("全球定位ip位置(离线版)")
        # 创建一个输入框,并设置尺寸
        self.ip_input = tkinter.Entry(self.root, width=30)

        # 创建一个回显列表
        self.display_info = tkinter.Listbox(self.root, width=50)

        # 创建一个查询结果的按钮
        self.result_button = tkinter.Button(self.root, command=self.find_position, text="查询")

    # 完成布局
    def gui_arrang(self):
        self.ip_input.pack()
        self.display_info.pack()
        self.result_button.pack()

    # 根据ip查找地理位置
    def find_position(self):
        # 获取输入信息
        self.ip_addr = self.ip_input.get()
        aim = self.gi.record_by_name(self.ip_addr)
        # 为了避免非法值,导致程序崩溃,有兴趣可以用正则写一下具体的规则,我为了便于新手理解,减少代码量,就直接粗放的过滤了
        try:

            # 获取目标城市
            city = aim["city"]
            # 获取目标国家
            country = aim["country_name"]
            # 获取目标地区
            region_code = aim["region_code"]
            # 获取目标经度
            longitude = aim["longitude"]
            # 获取目标纬度
            latitude = aim["latitude"]
        except:
            pass

        # 创建临时列表
        the_ip_info = ["所在纬度:" + str(latitude), "所在经度:" + str(longitude), "地域代号:" + str(region_code),
                       "所在城市:" + str(city), "所在国家或地区:" + str(country), "需要查询的ip:" + str(self.ip_addr)]
        # 清空回显列表可见部分,类似clear命令
        for item in range(10):
            self.display_info.insert(0, "")

        # 为回显列表赋值
        for item in the_ip_info:
            self.display_info.insert(0, item)
        # 这里的返回值,没啥用,就是为了好看
        return the_ip_info


def main():
    # 初始化对象
    FL = FindLocation()
    # 进行布局
    FL.gui_arrang()
    # 主程序执行
    tkinter.mainloop()
    pass

class GuiTest(object):

    def gui_test1(self):#helloworld
        win=tkinter.Tk();
        win.title("GUI 弹框居中")
        # 得到屏幕宽度
        sw = win.winfo_screenwidth()
        # 得到屏幕高度
        sh = win.winfo_screenheight()
        ww = 100
        wh = 100
        '''
        窗口宽高为100
        屏幕宽 - 窗口宽 = 窗口两边的宽度（记得是两边，仔细想想）
        然后我们除于一半得到屏幕左边的宽度，这就是我们窗口位于屏幕x轴开始的位置
        '''
        x = (sw - ww) / 2
        y = (sh - wh) / 2
        win.geometry("%dx%d+%d+%d" % (ww, wh, x, y))

    def gui_test2(self): #单组件填充满父组件
        root = tkinter.Tk();
        root.title("GUI pack单组件填充满父组件")
        text = tkinter.Text(root);
        # INSERT索引表示在光标处插入
        text.insert(tkinter.INSERT,"hello ")
        # END索引号表示在最后插入
        text.insert(tkinter.END, "world")
        text.pack(expand="yes", fill="both");

    def gui_test3(self): #多组件填充满父组件
        root = tkinter.Tk();
        root.title("GUI pack多组件填充满父组件")
        text = tkinter.Text(root);
        # INSERT索引表示在光标处插入
        text.insert(tkinter.INSERT,"hello world")
        text.pack(expand="yes", fill="both");

        btn=tkinter.Button(root,text="点我",background="blue",command=self.show);
        btn.pack(anchor="center",fill="y")
    def show(self):
        messagebox.showinfo(title="点我",message="真点啊");

    def gui_test4(self): #单组件填充满父组件
        root = tkinter.Tk();
        root.title("GUI grid单组件填充满父组件")
        root.rowconfigure(0, weight=1)
        root.columnconfigure(0, weight=1)
        text = tkinter.Text(root);
        # INSERT索引表示在光标处插入
        text.insert(tkinter.INSERT,"hello world")
        text.grid();

    def gui_test5(self): #多组件布局（滚动条）
        root = tkinter.Tk();
        root.title("GUI grid多组件布局（滚动条）")
        root.rowconfigure(0, weight=1)
        root.columnconfigure(0, weight=1)
        text = tkinter.Text(root);
        # INSERT索引表示在光标处插入
        text.insert(tkinter.INSERT,"hello world")
        text.grid();
        # 纵向
        sb = tkinter.Scrollbar(root)
        sb.grid(row=0, column=1, sticky='ns')
        text.configure(yscrollcommand=sb.set)
        sb.configure(command=text.yview)
        # 横向
        sb = tkinter.Scrollbar(root, orient='horizontal')
        sb.grid(row=1, column=0, sticky='ew')
        text.configure(xscrollcommand=sb.set)
        sb.configure(command=text.xview)

    def gui_test6(self):  # 绝对布局
        win = tkinter.Tk()
        win.title("GUI 绝对布局")  # #窗口标题
        win.geometry("600x500")  #主框体大小 #窗口位置500后面是字母x
        '''
        绝对布局
        '''
        label1 = tkinter.Label(win, text="柳多妍", bg="pink")
        label2 = tkinter.Label(win, text="多多", bg="yellow")
        label3 = tkinter.Label(win, text="超级飞侠", bg="red")
        # label1.pack()   # #默认没有布局，字有多长，背景也有多长，和其他label错落显示
        # label2.pack()
        # label3.pack()
        label1.place(x=10, y=10)  # #固定坐标，按绝对布局显示，窗口大小的变化对布局没有影响
        label2.place(x=50, y=50)
        label3.place(x=100, y=100)

    def gui_test7(self):  # 相对布局
        win = tkinter.Tk()
        win.title("GUI 相对布局")  # #窗口标题
        win.geometry("600x500+200+20")  # #窗口位置500后面是字母x
        '''
        相对布局,窗体改变对空间有影响
        '''
        label1 = tkinter.Label(win, text="柳多妍", bg="pink")
        label2 = tkinter.Label(win, text="多多", bg="yellow")
        label3 = tkinter.Label(win, text="超级飞侠", bg="red")
        label1.pack(fill=tkinter.Y, side=tkinter.LEFT)  # #相对布局
        label2.pack(fill=tkinter.X, side=tkinter.TOP)
        label3.pack()

    def gui_test8(self):  # 表格布局
        win = tkinter.Tk()
        win.title("GUI 表格布局")  # #窗口标题
        win.geometry("600x500+200+20")  # #窗口位置500后面是字母x

        '''
        相对布局,窗体改变对空间有影响
        '''
        label1 = tkinter.Label(win, text="柳多妍", bg="pink")
        label2 = tkinter.Label(win, text="多多", bg="yellow")
        label3 = tkinter.Label(win, text="超级飞侠", bg="red")
        label4 = tkinter.Label(win, text="小猪佩奇", bg="green")
        label1.grid(row=0, column=0)
        label2.grid(row=0, column=1)
        label3.grid(row=1, column=0)
        label4.grid(row=1, column=1)

    def gui_test9(self):  # 框架控件
        win = tkinter.Tk()
        win.title("GUI 框架控件")  # #窗口标题
        win.geometry("600x500+200+20")  # #窗口位置500后面是字母x
        '''
        框架控件，作用：作为一种容器，可以把其他空间放在frame上。
        '''
        frm = tkinter.Frame(win)  # #创建一个frame控件
        frm.pack()

        # #左侧
        frm_1 = tkinter.Frame(frm)  # #创建一个frm_1并且放到frm上
        tkinter.Label(frm_1, text="左上", bg="pink").pack(side=tkinter.TOP)  # #创建一个Lable放到frm_1上
        tkinter.Label(frm_1, text="左下", bg="green").pack(side=tkinter.TOP)
        frm_1.pack(side=tkinter.LEFT)  # #frm_1的位置放在左侧

        # #右侧
        frm_r = tkinter.Frame(frm)
        tkinter.Label(frm_r, text="右上", bg="red").pack(side=tkinter.TOP)
        tkinter.Label(frm_r, text="右下", bg="yellow").pack(side=tkinter.TOP)
        frm_r.pack(side=tkinter.RIGHT)

    def gui_test10(self):  # 界面切换
        win = tkinter.Tk()
        win.title("GUI 界面切换")  # #窗口标题
        win.geometry("600x500+200+20")  # #窗口位置500后面是字母x
        self.master = win
        self.master.config(bg='green')
        # 基准界面initface
        self.initface = tkinter.Frame(self.master, )
        self.initface.pack()
        btn = tkinter.Button(self.initface, text='change', command=self.change)
        btn.pack()

    def change(self):
        self.initface.destroy()
        self.master.config(bg='blue')
        self.face1 = tkinter.Frame(self.master, )
        self.face1.pack()
        btn_back = tkinter.Button(self.face1, text='face1 back', command=self.back)
        btn_back.pack()
    def back(self):
        self.face1.destroy()
        self.master.config(bg='green')
        # 基准界面initface
        self.initface = tkinter.Frame(self.master, )
        self.initface.pack()
        btn = tkinter.Button(self.initface, text='change', command=self.change)
        btn.pack()

    def gui_test11(self):  # 自定义tabview
        root = tkinter.Tk()
        root.geometry("640x300")

        tab_view = TabView(root, generate_body=self.create_body,
                           select_listen=self.select, remove_listen=self.remove)

        body = tab_view.body

        label_1 = tkinter.Label(tab_view.body, text="this is tab1")
        label_2 = tkinter.Label(tab_view.body, text="this is tab2")

        # 第一个参数是向body中添加的widget, 第二个参数是tab标题
        tab_view.add_tab(label_1, "tabs1")
        tab_view.add_tab(label_2, "tabs2")

        # TabView需要向x、y方向填充，且expand应设置为yes
        tab_view.pack(fill="both", expand='yes', pady=2)
        self.view=tab_view
        self.text="新标签"
        btn = tkinter.Button(root, text="新增", background="blue", command=self.addTab);
        btn.pack(anchor="center", fill="y")

    # 在body中生成widget的函数，返回的widget将被添加到tabview的body中
    def create_body(self):
        global body
        return tkinter.Label(body, text="this is body")

    # 点击选项卡时的回调
    def select(self,index):
        print("current selected -->", index)

    # 删除选项卡时的回调，如果返回False将不会删除
    def remove(self,index):
        print("remove tab -->", index)
        if messagebox.askokcancel("标题", "确定要关闭该选项卡吗？"):
            return True
        else:
            return False
    def addTab(self):
        print("add Tab -->")
        label_1 = tkinter.Label(self.view.body, text="this is tab1")
        self.view.add_tab(label_1, self.text)

if __name__ == "__main__":
   #main()
   FL = GuiTest()
   # 进行布局
   FL.gui_test11()
   # 主程序执行
   tkinter.mainloop()


